% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process.R
\name{process}
\alias{process}
\title{Create a system process object}
\usage{
process(pid = NULL)
}
\arguments{
\item{pid}{Process id, integer scalar. If not specified or \code{NULL},
the pid of the  calling process is used.}
}
\value{
\code{process} object.
}
\description{
Create a system process object
}
\section{Methods}{
\preformatted{p$pid()
}

Returns the process id.\preformatted{p$create_time()
}

Time stamp for the process creation, according to the OS. ps uses this
as an id, together with the pid.\preformatted{p$is_running()
}

Checks if the process is still running, returns \code{TRUE} or \code{FALSE}.
It returns the correct answer, even if the process has finished and
its pid was reused.\preformatted{p$status()
}

One of the following:
\itemize{
\item \code{"idle"}: Process being created by fork, macOS only.
\item \code{"running"}: Currently runnable on macOS and Windows. Actually running
on Linux.
\item \code{"sleeping"} Sleeping on a wait or poll.
\item \code{"disk_sleep"} Uninterruptible sleep, waiting for an I/O operation
(Linux only).
\item \code{"stopped"} Stopped, either by a job control signal or because it is
being traced.
\item \code{"tracing_stop"} Stopped for tracing (Linux only).
\item \code{"zombie"} Zombie. Finished, but parent has not read out the exit
status yet.
\item \code{"dead"} Should never be seen (Linux).
\item \code{"wake_kill"} Received fatal signal (Linux only).
\item \code{"waking"} Paging (Linux only, not valid since the 2.6.xx kernel).
}\preformatted{p$name()
}

Name of the process, typically the name of the executable. Note that on
Unix, this can change, e.g. via an \code{exec*()} system call.\preformatted{p$exe()
}

Path to the executable of the process. May also be an empty string or
\code{NA} if it cannot be determined.\preformatted{p$cmdline()
}

Command line of the process, i.e. the executable and the command line
arguments, in a character vector. On Unix the program might change its
command line, and some programs actually do it.\preformatted{p$cwd()
}

Process current working directory as an absolute path.\preformatted{p$environ()
}

The environment variables of the process, in a named vector, similarly
to the return value of \code{Sys.getenv()} (without arguments). Note: this
usually does not reflect changes made after the process started.\preformatted{p$username()
}

The name of the user that owns the process. On Unix it is calculated
from the real user id.\preformatted{p$uids()
p$guids()
}

User ids and group ids of the process. Not implemented on Windows,
throws \code{not_implemented} error. Both return integer vectors with names:
\code{real}, \code{effective} and \code{saved}.\preformatted{p$ppid()
}

Returns the parent process's id. Note that the ppid of a process might
change on Unix: typically when the parent process quits, it is set to 1,
which is the init process. (But not always, Linux can be configured to
use another pid, and pid 1 is usually not init in Docker.)

On Windows the ppid is not updated when the parent process exits, so
it might refer to a non-existant process, or even a different process
if the parent pid was reused.

The \code{parent()} method works around the Windows issue, by comparing
process creation times.\preformatted{p$parent()
}

Returns a process object for the parent process. On Unix, it will
return the reassigned (typically pid 1) process, if the real parent
process has quit aleady. On Windows it fails with \code{no_such_process}
error in this case.\preformatted{p$children(recursive = FALSE)
}

List of child processes (process objects) of the process. Note that this
typically requires enumerating all processes on the system, so it is a
costly operation.
\itemize{
\item \code{recursive}: whether to include the children of the children, etc.
}\preformatted{p$terminal()
}

Returns the terminal of the process. Not implemented on Windows, always
retuns \code{NA_character_}. On Unix it returns \code{NA_character_} if the
process has no terminal.\preformatted{p$num_threads()
}

The number threads.\preformatted{p$cpu_times()
}

Retuns a named real vector: \code{user}, \code{system}, \code{children_user},
\code{children_system}, all in seconds. The children times are typically
only available on Linux, and are \code{NA} on other platforms.\preformatted{p$memory_imfo()
}

A list with information about memory usage. Portable fields:
\itemize{
\item \code{rss}: "Resident Set Size", this is the non-swapped physical memory a
process has used. On UNIX it matches "top"‘s RES column (see doc). On
Windows this is an alias for \code{wset} field and it matches "Memory"
column of \code{taskmgr.exe}.
\item \code{vmem}: "Virtual Memory Size", this is the total amount of virtual
memory used by the process. On UNIX it matches "top"‘s VIRT column
(see doc). On Windows this is an alias for the \code{pagefile} field and it
matches the "Working set (memory)" column of \code{taskmgr.exe}.
}

Non-portable fields:
\itemize{
\item \code{shared}: (Linux) memory that could be potentially shared with other
processes. This matches "top"‘s SHR column (see doc).
\item \code{text}: (Linux): aka TRS (text resident set) the amount of memory
devoted to executable code. This matches "top"‘s CODE column (see
doc).
\item \code{data}: (Linux): aka DRS (data resident set) the amount of physical
memory devoted to other than executable code. It matches "top"‘s DATA
column (see doc).
\item \code{lib}: (Linux): the memory used by shared libraries.
\item \code{dirty}: (Linux): the number of dirty pages.
\item \code{pfaults}: (macOS): number of page faults.
\item \code{pageins}: (macOS): number of actual pageins.
}

For on explanation of Windows fields rely on
\href{http://msdn.microsoft.com/en-us/library/windows/desktop/ms684874(v=vs.85).aspx}{PROCESS_MEMORY_COUNTERS_EX}
structure doc.\preformatted{p$send_signal(sig)
}

Send a signal to the process. Not implemented on Windows. See \code{\link[=signal]{signal()}}
for the list of signals on the current platform.\preformatted{p$suspend()
}

Suspend process execution with \code{SIGSTOP} pre-emptively checking
whether PID has been reused. On Windows this has the effect of
suspending all process threads.\preformatted{p$resume()
}

Resume process execution with SIGCONT pre-emptively checking
whether PID has been reused. On Windows this has the effect of resuming
all process threads.\preformatted{p$terminate()
}

Send a \code{SIGTERM} signal to the process. Not implemented on Windows.\preformatted{p$kill()
}

Kill the current process with SIGKILL pre-emptively checking
whether PID has been reused.
}

\seealso{
See \code{\link[=with_process]{with_process()}} to query multiple pieces of information
about the process, potentially faster.
}
